use super::*;

const STANDARD_NEEDED: [u8; 47] = [
    0, 1, 4, 5, 7, 16, 17, 20, 21, 23, 28, 29, 31, 64, 65, 68, 69, 71, 80, 81, 84, 85, 87, 92, 93, 95, 112, 113, 116, 117, 119,
    124, 125, 127, 193, 197, 199, 209, 213, 215, 221, 223, 241, 245, 247, 253, 255,
];

impl GridCompleteAtlas {
    /// <http://www.cr31.co.uk/stagecast/wang/blob_g.html>
    pub fn from_blob7x7a(source: &RgbaImage, width: u32, height: u32) -> RgbaImage {
        let mut target = RgbaImage::new(width * 12, height * 4);
        unsafe {
            // needed tiles
            for mask in STANDARD_NEEDED {
                let (sw, sh) = blob7x7_sub_image(mask);
                let (tw, th) = complete_sub_image(mask);
                let view = source.view(sw * width, sh * height, width, height);
                target.copy_from(&*view, tw * width, th * height).unwrap_unchecked();
            }
            // default tile
            let (sw, sh) = (0, 0);
            let (tw, th) = (0, 3);
            let view = source.view(sw * width, sh * height, width, height);
            target.copy_from(&*view, tw * width, th * height).unwrap_unchecked();
        }
        target
    }
    pub fn from_edge4x4(source: &RgbaImage, width: u32, height: u32) -> RgbaImage {
        let mut target = RgbaImage::new(width * 12, height * 4);
        for i in 0..12 {
            for j in 0..4 {
                let (sw, sh) = edge_to_complete((i, j));
                let view = source.view(sw * width, sh * height, width, height);
                unsafe {
                    target.copy_from(&*view, i * width, j * height).unwrap_unchecked();
                }
            }
        }
        target
    }
}
fn rpg4x6_to_complete((x, y): (u32, u32)) -> (u32, u32) {
    match (x, y) {
        //
        (0, 0) => (0, 2),
        (0, 1) => (0, 3),
        (0, 2) => (0, 4),
        (0, 3) => (0, 3),
        (0, 4) => (0, 4),
        (0, 5) => (0, 5),
        (0, 6) => (0, 2),
        (0, 7) => (0, 5),
        //
        (1, 0) => (3, 2),
        (1, 1) => (3, 3),
        (1, 2) => (3, 4),
        (1, 3) => (3, 3),
        (1, 4) => (3, 4),
        (1, 5) => (3, 5),
        (1, 6) => (3, 2),
        (1, 7) => (3, 5),
        //
        (2, 0) => (0, 2),
        (2, 1) => (0, 3),
        (2, 2) => (0, 4),
        (2, 3) => (0, 3),
        (2, 4) => (0, 4),
        (2, 5) => (0, 5),
        (2, 6) => (0, 2),
        (2, 7) => (0, 5),
        //
        (3, 0) => (1, 2),
        (3, 1) => (3, 1),
        (3, 2) => (3, 0),
        (3, 3) => (3, 1),
        (3, 4) => (3, 0),
        (3, 5) => (1, 5),
        (3, 6) => (1, 2),
        (3, 7) => (1, 5),
        //
        (4, 0) => (2, 2),
        (4, 1) => (2, 1),
        (4, 2) => (2, 0),
        (4, 3) => (2, 1),
        (4, 4) => (2, 0),
        (4, 5) => (2, 5),
        (4, 6) => (2, 2),
        (4, 7) => (2, 5),
        //
        (5, 0) => (1, 2),
        (5, 1) => (3, 1),
        (5, 2) => (3, 0),
        (5, 3) => (3, 1),
        (5, 4) => (3, 0),
        (5, 5) => (1, 5),
        (5, 6) => (1, 2),
        (5, 7) => (1, 5),
        //
        (6, 0) => (2, 2),
        (6, 1) => (2, 1),
        (6, 2) => (2, 0),
        (6, 3) => (2, 1),
        (6, 4) => (2, 0),
        (6, 5) => (2, 5),
        (6, 6) => (2, 2),
        (6, 7) => (2, 5),
        //
        (7, 0) => (3, 2),
        (7, 1) => (3, 3),
        (7, 2) => (3, 4),
        (7, 3) => (3, 3),
        (7, 4) => (3, 4),
        (7, 5) => (3, 5),
        (7, 6) => (3, 2),
        (7, 7) => (3, 5),
        //
        (8, 0) => (2, 4),
        (8, 1) => (2, 1),
        (8, 2) => (0, 4),
        (8, 3) => (0, 3),
        (8, 4) => (0, 4),
        (8, 5) => (0, 3),
        (8, 6) => (2, 0),
        (8, 7) => (2, 3),
        //
        (9, 0) => (3, 0),
        (9, 1) => (3, 1),
        (9, 2) => (3, 0),
        (9, 3) => (1, 3),
        (9, 4) => (1, 4),
        (9, 5) => (3, 1),
        (9, 6) => (3, 0),
        (9, 7) => (3, 1),
    }
}

fn edge_to_complete((x, y): (u32, u32)) -> (u32, u32) {
    match (x, y) {
        (c, _) if c < 4 => (x, y),
        (4, 0) => (2, 1),
        (4, 1) => (1, 1),
        (4, 2) => (1, 1),
        (4, 3) => (2, 1),
        (5, 0) => (2, 0),
        (5, 1) => (2, 1),
        (5, 2) => (2, 1),
        (5, 3) => (2, 2),
        (6, 0) => (2, 0),
        (6, 1) => (2, 1),
        (6, 2) => (2, 1),
        (6, 3) => (2, 2),
        (7, 0) => (2, 1),
        (7, 1) => (3, 1),
        (7, 2) => (3, 1),
        (7, 3) => (2, 1),
        (8, 0) => (1, 0),
        (8, 1) => (1, 1),
        (8, 2) => (2, 1),
        (8, 3) => (1, 2),
        (9, 0) => (2, 1),
        (9, 1) => (2, 1),
        (9, 2) => (2, 1),
        (9, 3) => (2, 2),
        (10, 0) => (2, 0),
        (10, 1) => (0, 3), // empty
        (10, 2) => (2, 1),
        (10, 3) => (2, 1),
        (11, 0) => (3, 0),
        (11, 1) => (2, 1),
        (11, 2) => (3, 1),
        (11, 3) => (3, 2),
        _ => unreachable!(),
    }
}

fn complete_sub_image(mask: u8) -> (u32, u32) {
    match mask {
        0b00000000 => (10, 1),
        0b00000001 => (0, 2),
        0b00000100 => (1, 3),
        0b00000101 => (1, 2),
        0b00000111 => (8, 3),
        0b00010000 => (0, 0),
        0b00010001 => (0, 1),
        0b00010100 => (1, 0),
        0b00010101 => (1, 1),
        0b00010111 => (4, 2),
        0b00011100 => (8, 0),
        0b00011101 => (4, 1),
        0b00011111 => (8, 1),
        0b01000000 => (3, 3),
        0b01000001 => (3, 2),
        0b01000100 => (2, 3),
        0b01000101 => (2, 2),
        0b01000111 => (5, 3),
        0b01010000 => (3, 0),
        0b01010001 => (3, 1),
        0b01010100 => (2, 0),
        0b01010101 => (2, 1),
        0b01010111 => (7, 0),
        0b01011100 => (5, 0),
        0b01011101 => (7, 3),
        0b01011111 => (8, 2),
        0b01110000 => (11, 0),
        0b01110001 => (7, 1),
        0b01110100 => (6, 0),
        0b01110101 => (4, 3),
        0b01110111 => (9, 1),
        0b01111100 => (10, 0),
        0b01111101 => (9, 0),
        0b01111111 => (5, 1),
        0b11000001 => (11, 3),
        0b11000101 => (6, 3),
        0b11000111 => (9, 3),
        0b11010001 => (7, 2),
        0b11010101 => (4, 0),
        0b11010111 => (10, 3),
        0b11011101 => (10, 2),
        0b11011111 => (5, 2),
        0b11110001 => (11, 2),
        0b11110101 => (11, 1),
        0b11110111 => (6, 2),
        0b11111101 => (6, 1),
        0b11111111 => (9, 2),
        _ => (0, 3),
    }
}

/// <https://opengameart.org/content/seamless-tileset-template-ii>
fn blob7x7_sub_image(mask: u8) -> (u32, u32) {
    match mask {
        0b00000000 => (0, 6),
        0b00000001 => (1, 6),
        0b00000100 => (1, 0),
        0b00000101 => (0, 5),
        0b00000111 => (2, 6),
        0b00010000 => (0, 1),
        0b00010001 => (6, 5),
        0b00010100 => (1, 1),
        0b00010101 => (5, 1),
        0b00010111 => (0, 4),
        0b00011100 => (3, 3),
        0b00011101 => (0, 2),
        0b00011111 => (0, 3),
        0b01000000 => (6, 1),
        0b01000001 => (6, 6),
        0b01000100 => (5, 6),
        0b01000101 => (4, 6),
        0b01000111 => (3, 2),
        0b01010000 => (5, 0),
        0b01010001 => (6, 4),
        0b01010100 => (1, 5),
        0b01010101 => (2, 2),
        0b01010111 => (2, 1),
        0b01011100 => (2, 0),
        0b01011101 => (2, 5),
        0b01011111 => (3, 4),
        0b01110000 => (6, 2),
        0b01110001 => (2, 3),
        0b01110100 => (4, 0),
        0b01110101 => (1, 2),
        0b01110111 => (3, 5),
        0b01111100 => (3, 0),
        0b01111101 => (5, 2),
        0b01111111 => (4, 3),
        0b11000001 => (5, 5),
        0b11000101 => (3, 6),
        0b11000111 => (1, 4),
        0b11010001 => (6, 3),
        0b11010101 => (2, 4),
        0b11010111 => (4, 5),
        0b11011101 => (4, 2),
        0b11011111 => (3, 1),
        0b11110001 => (4, 1),
        0b11110101 => (5, 4),
        0b11110111 => (5, 3),
        0b11111101 => (1, 3),
        0b11111111 => (4, 4),
        _ => (0, 0),
    }
}
